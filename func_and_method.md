# 函数功能要单一

函数功能要单一，过长的函数往往意味着函数功能不单一。可以进一步拆分或分层。而且过于复杂的函数往往不利于阅读，难以维护。

原则如下：

- 函数行数，建议不超过50行（非空非注释）
- 函数的参数个数，建议不超过5个，多了建议用结构体替代
- 最大代码块嵌套深度，建议不超过4层。
- 函数的返回值不超过3个



# 合理选择方法的接受者

合理选择方法接受者的类型，对代码的可读性，和维护性都有不同的影响。

原则如下：

- 如果方法不会改变接受者的内容，使用值类型，表明方法的const定义。
- 如果接收者是大型结构体或者数组，可考虑指针类型，提高效率。
- 如果接受者包含sync.Mutex或类似同步字段的结构体，则必须使用指针，以免被复制。
- 如果接收者是map、func、或者chan，不要使用指针类型。
- 如果方法接收者是slice，且方法中不会修改接受者容量，或者重新分配内存，不要使用指针类型。

# 避免使用具名返回值

优先使用返回值，而且错误值和返回值不要复用一个返回值。

**反例**

```go
func newInt(i int) (i int) {  // 不符合，通过传入的指针来修改外部的实参值
	i++
}
```

**正例**

```go
func newInt(i int) int {
	return i++
}
```

# 返回已被修改大小的slice对象

slice 的append 操作有可能修改slice指向的地址，如果函数被设计用于更新传入的slice参数，则他的实现需要满足：

如函数包含的slice的参数（不是slice指针），并对其append操作，必须返回修改后的slice。

**反例**

```go
func appendSlice(s []int){ // 不符合：修改了slice大小，因此必须返回slice
    s[0] = 10 // 符合：只是修改内容没有修改大小
    s = append(s,11) // 不符合：修改了大小，如函数不返回s则不符合规则。
}
```

**正例**

```go
func appendSlice(s []int) []int { 
    s[0] = 10 
    s2 = append(s,11)
	return s2
}
```

# 避免栈调用层次太深

调用层次太深，在栈上分配大量内存，容易导致出现栈溢出错误。GO语音有一些容易让函数调用陷入无限递归的情况，需要避免。

- 指定嵌入类型成员调用嵌入类型的方法。
- 确保String()方法不会被无限递归。

**反例**

```go
func (j *job) Printf(str string) {
    j.Printf(str string) // 不符合：直接调用j.Printf会导致无限递归调用
}
```

**正例**

```go
func (j *job) Printf(str string) {
    j.Logger.Printf(str string) 
}
```

# 方法参数当传递的值为较大的结构体时，应传递指针，避免底层复制

参数是map，slice，chan不要传递指针，因为map，slice，chan是引用类型，当不需要修改map，slice内容时不要传递指针的指针。